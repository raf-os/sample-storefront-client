import GlobalConfig from "@/lib/globalConfig";
import type { HttpMethod, PathsWithMethod, SuccessResponseJSON, ErrorResponseJSON } from "openapi-typescript-helpers";
import type { paths } from "@/api/schema";
import { QueryClient } from "@tanstack/react-query";

import TokenRefreshHandler from "@/handlers/TokenRefreshHandler";
import AuthSingleton from "@/classes/AuthSingleton";
import { CustomResponseError } from "@/classes/errors";

/*
    Keep an eye on these functions, nearly half of these were generated by an LLM and are likely to not function as intended.
*/

const queryClient = new QueryClient({
    defaultOptions: {
        queries: {}
    }
});

function replacePath(path: string, params?: Record<string, string | number>): string {
    if (!params) return path;
    
    let result = path;
    for (const [key, value] of Object.entries(params)) {
        result = result.replace(`{${key}}`, encodeURIComponent(String(value)));
    }
    return result;
}

function serializeQuery(params?: Record<string, any>): string {
    if (!params) return '';
    
    const searchParams = new URLSearchParams();
    
    for (const [key, value] of Object.entries(params)) {
        if (value === undefined || value === null) continue;
        
        if (Array.isArray(value)) {
            value.forEach(v => searchParams.append(key, String(v)));
        } else if (typeof value === 'object') {
            searchParams.append(key, JSON.stringify(value));
        } else {
            searchParams.append(key, String(value));
        }
    }
    
    const query = searchParams.toString();
    return query ? `?${query}` : '';
}

type PathParams<Path extends keyof paths, Method extends keyof paths[Path]> = 
    paths[Path][Method] extends { parameters: { path: infer P } } ? P : never;

type QueryParams<Path extends keyof paths, Method extends keyof paths[Path]> = 
    paths[Path][Method] extends { parameters: { query: infer Q } } ? Q : never;

type RequestBody<Path extends keyof paths, Method extends keyof paths[Path]> =
    paths[Path][Method] extends { requestBody: { content: infer Q } }
        ? Q extends { "application/json": infer R }
            ? R
            : Q extends { "application/x-www-form-urlencoded": any }
                ? FormData
                : never
        : never;

type MaybeOptionalBody<Path extends keyof paths, Method extends keyof paths[Path]> = RequestBody<Path, Method> extends never
    ? { body?: never } : { body: RequestBody<Path, Method> };

export class CustomResponse<
    Method extends HttpMethod,
    Path extends PathsWithMethod<paths, Method>,
> {
    resObj: Response;

    constructor(res: Response) {
        this.resObj = res;
    }

    async Parse() {
        const res = this.resObj;

        if (res.headers.get("Content-Length") === "0") {
            // Handle no-content responses
            if (res.ok) {
                return undefined as SuccessResponseJSON<paths[Path][Method] & Record<string | number, any>>;
            } else {
                throw new CustomResponseError(res.status);
            }
        }

        const data = await res.json();

        if (res.ok) {
            return data as SuccessResponseJSON<paths[Path][Method] & Record<string | number, any>>;
        } else {
            throw new CustomResponseError<ErrorResponseJSON<paths[Path][Method] & Record<string | number, any>>>(res.status, "Fetch error:", data);
        }
    }
}

export interface IRequestMetadata {
    useAuth?: boolean
}

export async function serverRequest<
    Method extends HttpMethod,
    Path extends PathsWithMethod<paths, Method>
>(
    method: Method,
    path: Path,
    options?: {
        params?: {
            path?: PathParams<Path, Method>,
            query?: QueryParams<Path, Method>
        },
        body?: MaybeOptionalBody<Path, Method>,
        headers?: HeadersInit
    },
    metadata?: IRequestMetadata
): Promise<SuccessResponseJSON<paths[Path][Method] & Record<string | number, any>>> {
    const baseUrl = GlobalConfig.ServerAddr;

    let url = replacePath(String(path), options?.params?.path as any);
    url += serializeQuery(options?.params?.query as any);

    const headers = { ...options?.headers };

    const fetchOptions: RequestInit = {
        method: String(method).toUpperCase(),
        headers
    }

    if (options?.body && ['POST', 'PUT', 'PATCH'].includes(String(method).toUpperCase())) {
        if (options.body && (options.body as unknown) instanceof FormData) fetchOptions.body = options.body as FormData;
        else fetchOptions.body = JSON.stringify(options.body);
    }

    const req = new Request(`${baseUrl}${url}`, fetchOptions);

    if (metadata?.useAuth === true) {
        await TokenRefreshHandler.validateToken();
        const token = await AuthSingleton.getJwtToken();

        req.headers.set("Authorization", `Bearer ${token}`);
    }

    const response = await queryClient.fetchQuery({
        queryKey: [ method, path, options?.params ],
        queryFn: async () => {
            const res = await fetch(req);
            const custom = new CustomResponse<Method, Path>(res);
            const data = await custom.Parse();
            return data;
        }
    });

    // if (!response.ok) throw new Error(`API Error: ${response.status}`);

    return response;
}